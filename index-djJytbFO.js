import{l as $,a as j,i as q,m as W,E as M,e as T,C as v,c as Q,d as X,f as H,A as D,r as Y,W as Z,h as ee,p as te,j as ne}from"./index-foPiI00A.js";import{p as re}from"./index-PRs5a-SV.js";const z=421,se=290,oe=2e3,I=$("libp2p:webrtc-star:socket");function F(t,e){const{sink:n,source:r}=t,s={remoteAddr:e.remoteAddr,async sink(o){e.signal!=null&&(o=j(o,e.signal));try{await n(o)}catch(c){c.type!=="aborted"&&I.error(c)}},source:e.signal!=null?j(r,e.signal):r,timeline:{open:Date.now()},async close(){if(t.closed)return;const o=Date.now(),c=setTimeout(()=>{if(s.remoteAddr!=null){const{host:i,port:a}=s.remoteAddr.toOptions();I("timeout closing socket to %s:%s after %dms, destroying it manually",i,a,Date.now()-o)}t.closed||t.close().catch(i=>{I.error("could not close socket",i)})},oe);try{await t.close()}finally{clearTimeout(c)}}};return t.addEventListener("close",()=>{s.timeline.close==null&&(s.timeline.close=Date.now())},{once:!0}),s}function G(t){const e=t.toString().split("/"),n=t.protos()[1].name,r=t.protos()[2].name,s=t.stringTuples()[1][1];if(n!=="tcp"||r!=="ws"&&r!=="wss")throw new Error(`invalid multiaddr: ${t.toString()}`);if(!q(t))return`http://${e[2]}:${e[4]}`;if(r==="ws")return`http://${e[2]}${s==null||s==="80"?"":`:${s}`}`;if(r==="wss")return`https://${e[2]}${s==null||s==="443"?"":`:${s}`}`;throw new Error("invalid multiaddr: "+t.toString())}function ie(t){const e="/libp2p-webrtc-star";if(t.startsWith(e)){t=t.substring(e.length,t.length);let n=W(t);const r=n.stringTuples().filter(s=>s[0]===421)[0];if(r[1]==null)throw new Error("invalid multiaddr: "+t);n=n.decapsulate("p2p"),n=n.encapsulate("/p2p-webrtc-star"),n=n.encapsulate(`/p2p/${r[1]}`),t=n.toString()}return t}const p=$("libp2p:webrtc-star:listener"),ae={transports:["websocket"],path:"/socket.io-next/"};class ce extends M{constructor(e,n,r,s,o){super(),this.signallingAddr=n,this.socket=Q(e,ae),this.connections=[],this.channels=new Map,this.pendingSignals=new Map,this.upgrader=r,this.handler=s,this.channelOptions=o,this.handleWsHandshake=this.handleWsHandshake.bind(this);let c=!1;this.socket.on("connect_error",i=>{c&&i.type==="TransportError"||this.dispatchEvent(new v("error",{detail:i}))}),this.socket.on("error",i=>{this.dispatchEvent(new v("error",{detail:i}))}),this.socket.on("ws-handshake",this.handleWsHandshake),this.socket.on("ws-peer",i=>{this.dispatchEvent(new v("peer",{detail:i}))}),this.socket.on("connect",()=>{this.socket.emit("ss-join",this.signallingAddr.toString()),c&&this.dispatchEvent(new v("reconnect"))}),this.socket.once("connect",()=>{c=!0,this.dispatchEvent(new v("listening"))}),this.socket.on("disconnect",()=>{this.dispatchEvent(new v("disconnect"))})}_createChannel(e,n,r){const s={...this.channelOptions},o=new X(s),c=i=>{const a=i.detail;p.error("incoming connection errored",a)};return o.addEventListener("error",c),o.addEventListener("close",()=>{o.removeEventListener("error",c)},{once:!0}),o.addEventListener("signal",i=>{const a=i.detail;this.socket.emit("ss-handshake",{intentId:e,srcMultiaddr:n,dstMultiaddr:r,answer:!0,signal:a})}),o.addEventListener("ready",()=>{const i=F(o,{remoteAddr:this.signallingAddr});p("new inbound connection %s",i.remoteAddr);try{this.upgrader.upgradeInbound(i).then(a=>{p("inbound connection %s upgraded",i.remoteAddr),this.connections.push(i);const b=()=>{this.connections=this.connections.filter(h=>h!==i),this.channels.delete(e),this.pendingSignals.delete(e)};o.addEventListener("close",b,{once:!0}),this.dispatchEvent(new v("connection",{detail:a})),this.handler(a)}).catch(a=>{p.error("inbound connection failed to upgrade",a),i.close().catch(b=>{p.error("inbound connection failed to close after failing to upgrade",b)})})}catch(a){p.error("inbound connection failed to upgrade",a),i.close().catch(b=>{p.error("inbound connection failed to close after failing to upgrade",b)})}},{once:!0}),o}handleWsHandshake(e){if(p('incoming handshake. signal type "%s" is answer %s',e.signal.type,e.answer),e.answer===!0||e.err!=null||e.intentId==null)return;const n=e.intentId;let r=this.pendingSignals.get(n);r==null&&(r=[],this.pendingSignals.set(n,r)),r.push(e);let s=this.channels.get(n);if(s==null){if(e.signal.type!=="offer"){p("handshake is not an offer and channel does not exist, buffering until we receive an offer");return}p("creating new channel to handle offer handshake"),s=this._createChannel(e.intentId,e.srcMultiaddr,e.dstMultiaddr),this.channels.set(n,s)}else p("channel already exists, using it to handle handshake");for(;r.length>0;){const o=r.shift();o?.signal!=null&&s.handleSignal(o.signal)}}async close(){this.socket.emit("ss-leave",this.signallingAddr.toString()),this.socket.removeAllListeners(),this.socket.close(),await Promise.all([...this.connections.map(async e=>{await e.close()}),...Array.from(this.channels.values()).map(async e=>{await e.close()})]),this.dispatchEvent(new v("close"))}}class le extends M{constructor(e,n,r,s,o){super(),this.upgrader=e,this.handler=n,this.peerId=r,this.transport=s,this.options=o}async listen(e){if(this.listeningAddr!=null)throw T(new Error("listener already in use"),"ERR_ALREADY_LISTENING");const n=re();this.listeningAddr=e;let r;e.protoCodes().includes(z)?r=e:r=e.encapsulate(`/p2p/${this.peerId.toString()}`);const s=this.signallingUrl=G(e);p("connecting to signalling server on: %s",this.signallingUrl);const o=new ce(this.signallingUrl,r,this.upgrader,this.handler,this.options.channelOptions);o.addEventListener("error",c=>{const i=c.detail;p("error connecting to signalling server %o",i),o.close().catch(a=>{p.error("error closing server after error",a)}),n.reject(i)}),o.addEventListener("listening",()=>{p("connected to signalling server"),this.dispatchEvent(new v("listening")),n.resolve()}),o.addEventListener("peer",c=>{this.transport.peerDiscovered(c.detail)}),o.addEventListener("connection",c=>{const i=c.detail;if(i.remoteAddr==null)try{i.remoteAddr=e.decapsulateCode(z).encapsulate(`/p2p/${i.remotePeer.toString()}`)}catch(a){p.error("could not determine remote address",a)}this.dispatchEvent(new v("connection",{detail:i}))}),o.addEventListener("disconnect",()=>{this.transport.sigServers.delete(s)}),o.addEventListener("reconnect",()=>{this.transport.sigServers.set(s,o)}),this.transport.sigServers.set(this.signallingUrl,o),await n.promise}async close(){if(this.signallingUrl!=null){const e=this.transport.sigServers.get(this.signallingUrl);e!=null&&(await e.close(),this.transport.sigServers.delete(this.signallingUrl))}this.dispatchEvent(new v("close")),this.listeningAddr=void 0}getAddrs(){return this.listeningAddr!=null?[this.listeningAddr]:[]}}function de(t,e,n,r,s){return new le(t,e,n,r,s)}function he(t){return globalThis.Buffer!=null?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t}function ue(t=0){return globalThis.Buffer?.allocUnsafe!=null?he(globalThis.Buffer.allocUnsafe(t)):new Uint8Array(t)}function pe(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var s=0;s<t.length;s++){var o=t.charAt(s),c=o.charCodeAt(0);if(n[c]!==255)throw new TypeError(o+" is ambiguous");n[c]=s}var i=t.length,a=t.charAt(0),b=Math.log(i)/Math.log(256),h=Math.log(256)/Math.log(i);function C(l){if(l instanceof Uint8Array||(ArrayBuffer.isView(l)?l=new Uint8Array(l.buffer,l.byteOffset,l.byteLength):Array.isArray(l)&&(l=Uint8Array.from(l))),!(l instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(l.length===0)return"";for(var d=0,g=0,f=0,m=l.length;f!==m&&l[f]===0;)f++,d++;for(var E=(m-f)*h+1>>>0,w=new Uint8Array(E);f!==m;){for(var S=l[f],_=0,y=E-1;(S!==0||_<g)&&y!==-1;y--,_++)S+=256*w[y]>>>0,w[y]=S%i>>>0,S=S/i>>>0;if(S!==0)throw new Error("Non-zero carry");g=_,f++}for(var A=E-g;A!==E&&w[A]===0;)A++;for(var P=a.repeat(d);A<E;++A)P+=t.charAt(w[A]);return P}function O(l){if(typeof l!="string")throw new TypeError("Expected String");if(l.length===0)return new Uint8Array;var d=0;if(l[d]!==" "){for(var g=0,f=0;l[d]===a;)g++,d++;for(var m=(l.length-d)*b+1>>>0,E=new Uint8Array(m);l[d];){var w=n[l.charCodeAt(d)];if(w===255)return;for(var S=0,_=m-1;(w!==0||S<f)&&_!==-1;_--,S++)w+=i*E[_]>>>0,E[_]=w%256>>>0,w=w/256>>>0;if(w!==0)throw new Error("Non-zero carry");f=S,d++}if(l[d]!==" "){for(var y=m-f;y!==m&&E[y]===0;)y++;for(var A=new Uint8Array(g+(m-y)),P=g;y!==m;)A[P++]=E[y++];return A}}}function k(l){var d=O(l);if(d)return d;throw new Error(`Non-${e} character`)}return{encode:C,decodeUnsafe:O,decode:k}}var fe=pe,be=fe;const ge=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},we=t=>new TextEncoder().encode(t),ve=t=>new TextDecoder().decode(t);class ye{constructor(e,n,r){this.name=e,this.prefix=n,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class me{constructor(e,n,r){if(this.name=e,this.prefix=n,n.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=n.codePointAt(0),this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return V(this,e)}}class Ee{constructor(e){this.decoders=e}or(e){return V(this,e)}decode(e){const n=e[0],r=this.decoders[n];if(r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const V=(t,e)=>new Ee({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class Se{constructor(e,n,r,s){this.name=e,this.prefix=n,this.baseEncode=r,this.baseDecode=s,this.encoder=new ye(e,n,r),this.decoder=new me(e,n,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const R=({name:t,prefix:e,encode:n,decode:r})=>new Se(t,e,n,r),U=({prefix:t,name:e,alphabet:n})=>{const{encode:r,decode:s}=be(n,e);return R({prefix:t,name:e,encode:r,decode:o=>ge(s(o))})},Ae=(t,e,n,r)=>{const s={};for(let h=0;h<e.length;++h)s[e[h]]=h;let o=t.length;for(;t[o-1]==="=";)--o;const c=new Uint8Array(o*n/8|0);let i=0,a=0,b=0;for(let h=0;h<o;++h){const C=s[t[h]];if(C===void 0)throw new SyntaxError(`Non-${r} character`);a=a<<n|C,i+=n,i>=8&&(i-=8,c[b++]=255&a>>i)}if(i>=n||255&a<<8-i)throw new SyntaxError("Unexpected end of data");return c},_e=(t,e,n)=>{const r=e[e.length-1]==="=",s=(1<<n)-1;let o="",c=0,i=0;for(let a=0;a<t.length;++a)for(i=i<<8|t[a],c+=8;c>n;)c-=n,o+=e[s&i>>c];if(c&&(o+=e[s&i<<n-c]),r)for(;o.length*n&7;)o+="=";return o},u=({name:t,prefix:e,bitsPerChar:n,alphabet:r})=>R({prefix:e,name:t,encode(s){return _e(s,r,n)},decode(s){return Ae(s,r,n,t)}}),xe=U({prefix:"9",name:"base10",alphabet:"0123456789"}),Ce=Object.freeze(Object.defineProperty({__proto__:null,base10:xe},Symbol.toStringTag,{value:"Module"})),Oe=u({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Te=u({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Ue=Object.freeze(Object.defineProperty({__proto__:null,base16:Oe,base16upper:Te},Symbol.toStringTag,{value:"Module"})),ke=u({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Pe=Object.freeze(Object.defineProperty({__proto__:null,base2:ke},Symbol.toStringTag,{value:"Module"})),J=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Re=J.reduce((t,e,n)=>(t[n]=e,t),[]),Ie=J.reduce((t,e,n)=>(t[e.codePointAt(0)]=n,t),[]);function Le(t){return t.reduce((e,n)=>(e+=Re[n],e),"")}function $e(t){const e=[];for(const n of t){const r=Ie[n.codePointAt(0)];if(r===void 0)throw new Error(`Non-base256emoji character: ${n}`);e.push(r)}return new Uint8Array(e)}const Me=R({prefix:"ðŸš€",name:"base256emoji",encode:Le,decode:$e}),je=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Me},Symbol.toStringTag,{value:"Module"})),De=u({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),ze=u({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ne=u({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Be=u({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),We=u({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Fe=u({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Ge=u({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Ve=u({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Je=u({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Ke=Object.freeze(Object.defineProperty({__proto__:null,base32:De,base32hex:We,base32hexpad:Ge,base32hexpadupper:Ve,base32hexupper:Fe,base32pad:Ne,base32padupper:Be,base32upper:ze,base32z:Je},Symbol.toStringTag,{value:"Module"})),qe=U({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Qe=U({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Xe=Object.freeze(Object.defineProperty({__proto__:null,base36:qe,base36upper:Qe},Symbol.toStringTag,{value:"Module"})),He=U({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Ye=U({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Ze=Object.freeze(Object.defineProperty({__proto__:null,base58btc:He,base58flickr:Ye},Symbol.toStringTag,{value:"Module"})),et=u({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),tt=u({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),nt=u({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),rt=u({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),st=Object.freeze(Object.defineProperty({__proto__:null,base64:et,base64pad:tt,base64url:nt,base64urlpad:rt},Symbol.toStringTag,{value:"Module"})),ot=u({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),it=Object.freeze(Object.defineProperty({__proto__:null,base8:ot},Symbol.toStringTag,{value:"Module"})),at=R({prefix:"\0",name:"identity",encode:t=>ve(t),decode:t=>we(t)}),ct=Object.freeze(Object.defineProperty({__proto__:null,identity:at},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const N={...ct,...Pe,...it,...Ce,...Ue,...Ke,...Xe,...Ze,...st,...je};function K(t,e,n,r){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:n},decoder:{decode:r}}}const B=K("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),L=K("ascii","a",t=>{let e="a";for(let n=0;n<t.length;n++)e+=String.fromCharCode(t[n]);return e},t=>{t=t.substring(1);const e=ue(t.length);for(let n=0;n<t.length;n++)e[n]=t.charCodeAt(n);return e}),lt={utf8:B,"utf-8":B,hex:N.base16,latin1:L,ascii:L,binary:L,...N};function dt(t,e="utf8"){const n=lt[e];if(n==null)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(t.buffer,t.byteOffset,t.byteLength).toString("utf8"):n.encoder.encode(t).substring(1)}const ht="RTCPeerConnection"in globalThis,x=$("libp2p:webrtc-star"),ut=()=>{};class pt extends M{constructor(){super(...arguments),this.started=!1}get[ne](){return!0}get[Symbol.toStringTag](){return"@libp2p/webrtc-star-discovery"}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}dispatchEvent(e){return this.isStarted()?super.dispatchEvent(e):!1}}class ft{constructor(e){e?.wrtc!=null&&(this.wrtc=e.wrtc),this.sigServers=new Map,this._discovery=new pt,this.discovery=()=>this._discovery,this.peerDiscovered=this.peerDiscovered.bind(this)}get[H](){return!0}get[Symbol.toStringTag](){return"@libp2p/webrtc-star"}async dial(e,n){const r=await this._connect(e,n),s=F(r,{remoteAddr:e,signal:n.signal});x("new outbound connection %s",s.remoteAddr);const o=await n.upgrader.upgradeOutbound(s);return x("outbound connection %s upgraded",s.remoteAddr),o}async _connect(e,n){if(n.signal?.aborted===!0)throw new D;const r={...n.channelOptions??{}};this.wrtc!=null&&(r.wrtc=this.wrtc);const s=e.toOptions(),o=dt(Y(36),"hex");return await new Promise((c,i)=>{const a=this.sigServers.get(G(e));if(a?.socket==null){i(T(new Error("unknown signal server to use"),"ERR_UNKNOWN_SIGNAL_SERVER"));return}let b=!1;x("dialing %s:%s",s.host,s.port);const h=new Z(r),C=d=>{const g=d.detail;if(!b){const f=`connection error ${s.host}:${s.port}: ${g.message}`;x.error(f),l(g)}},O=()=>{b=!0,x("connection opened %s:%s",s.host,s.port),l()},k=()=>{x.error("connection aborted %s:%s",s.host,s.port),h.close().finally(()=>{l(new D)})},l=d=>{h.removeEventListener("ready",O),n.signal?.removeEventListener("abort",k),d==null?c(h):i(d)};h.addEventListener("ready",O,{once:!0}),h.addEventListener("close",()=>{h.removeEventListener("error",C)}),n.signal?.addEventListener("abort",k),h.addEventListener("signal",d=>{const g=d.detail;a.socket.emit("ss-handshake",{intentId:o,srcMultiaddr:a.signallingAddr.toString(),dstMultiaddr:e.toString(),signal:g})}),a.socket.on("ws-handshake",d=>{d.intentId===o&&d.err!=null&&h.close().finally(()=>{i(T(new Error(d.err),"ERR_SIGNALLING_FAILED"))}),!(d.intentId!==o||d.answer==null||h.closed)&&h.handleSignal(d.signal)})})}createListener(e){if(!ht&&this.wrtc==null)throw T(new Error("no WebRTC support"),"ERR_NO_WEBRTC_SUPPORT");if(e.channelOptions=e.channelOptions??{},this.wrtc!=null&&(e.channelOptions.wrtc=this.wrtc),this.peerId==null)throw T(new Error("PeerId not set"),"ERR_MISSING_PEER_ID");return de(e.upgrader,e.handler??ut,this.peerId,this,e)}filter(e){return e=Array.isArray(e)?e:[e],e.filter(n=>n.protoCodes().includes(se)?!1:ee.matches(n))}peerDiscovered(e){x("peer discovered: %s",e),e=ie(e);const n=W(e),r=n.getPeerId();if(r==null)return;const s=te(r);this._discovery.dispatchEvent(new v("peer",{detail:{id:s,multiaddrs:[n],protocols:[]}}))}}function wt(t={}){const e=new ft(t);return{transport:n=>(e.peerId=n.peerId,e),discovery:e.discovery}}export{wt as w};
//# sourceMappingURL=index-djJytbFO.js.map
