{"version":3,"file":"index-2UhJknYY.js","sources":["../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/constants.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/socket-to-conn.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/utils.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/listener.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/uint8arrays/dist/src/util/as-uint8array.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/uint8arrays/dist/src/alloc.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/vendor/base-x.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bytes.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base10.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base16.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base2.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base256emoji.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base32.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base36.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base58.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base64.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/base8.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/bases/identity.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/codecs/json.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/multiformats/src/basics.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/uint8arrays/dist/src/util/bases.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/node_modules/uint8arrays/dist/src/to-string.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/transport.js","../../../../node_modules/@constl/ipa/node_modules/@libp2p/webrtc-star/dist/src/index.js"],"sourcesContent":["// p2p multi-address code\nexport const CODE_P2P = 421;\nexport const CODE_CIRCUIT = 290;\n// Time to wait for a connection to close gracefully before destroying it manually\nexport const CLOSE_TIMEOUT = 2000;\n//# sourceMappingURL=constants.js.map","import { abortableSource } from 'abortable-iterator';\nimport { CLOSE_TIMEOUT } from './constants.js';\nimport { logger } from '@libp2p/logger';\nconst log = logger('libp2p:webrtc-star:socket');\n/**\n * Convert a socket into a MultiaddrConnection\n * https://github.com/libp2p/js-libp2p-interfaces/tree/master/src/transport#multiaddrconnection\n */\nexport function toMultiaddrConnection(socket, options) {\n    const { sink, source } = socket;\n    const maConn = {\n        remoteAddr: options.remoteAddr,\n        async sink(source) {\n            if (options.signal != null) {\n                source = abortableSource(source, options.signal);\n            }\n            try {\n                await sink(source);\n            }\n            catch (err) {\n                // If aborted we can safely ignore\n                if (err.type !== 'aborted') {\n                    // If the source errored the socket will already have been destroyed by\n                    // toIterable.duplex(). If the socket errored it will already be\n                    // destroyed. There's nothing to do here except log the error & return.\n                    log.error(err);\n                }\n            }\n        },\n        source: (options.signal != null) ? abortableSource(source, options.signal) : source,\n        timeline: { open: Date.now() },\n        async close() {\n            if (socket.closed) {\n                return;\n            }\n            const start = Date.now();\n            // Attempt to end the socket. If it takes longer to close than the\n            // timeout, destroy it manually.\n            const timeout = setTimeout(() => {\n                if (maConn.remoteAddr != null) {\n                    const { host, port } = maConn.remoteAddr.toOptions();\n                    log('timeout closing socket to %s:%s after %dms, destroying it manually', host, port, Date.now() - start);\n                }\n                if (!socket.closed) {\n                    socket.close().catch(err => {\n                        log.error('could not close socket', err);\n                    });\n                }\n            }, CLOSE_TIMEOUT);\n            try {\n                await socket.close();\n            }\n            finally {\n                clearTimeout(timeout);\n            }\n        }\n    };\n    socket.addEventListener('close', () => {\n        // In instances where `close` was not explicitly called,\n        // such as an iterable stream ending, ensure we have set the close\n        // timeline\n        if (maConn.timeline.close == null) {\n            maConn.timeline.close = Date.now();\n        }\n    }, {\n        once: true\n    });\n    return maConn;\n}\n//# sourceMappingURL=socket-to-conn.js.map","import { multiaddr, isName } from '@multiformats/multiaddr';\nexport function cleanUrlSIO(ma) {\n    const maStrSplit = ma.toString().split('/');\n    const tcpProto = ma.protos()[1].name;\n    const wsProto = ma.protos()[2].name;\n    const tcpPort = ma.stringTuples()[1][1];\n    if (tcpProto !== 'tcp' || (wsProto !== 'ws' && wsProto !== 'wss')) {\n        throw new Error(`invalid multiaddr: ${ma.toString()}`);\n    }\n    if (!isName(ma)) {\n        return `http://${maStrSplit[2]}:${maStrSplit[4]}`;\n    }\n    if (wsProto === 'ws') {\n        return `http://${maStrSplit[2]}${tcpPort == null || tcpPort === '80' ? '' : `:${tcpPort}`}`;\n    }\n    if (wsProto === 'wss') {\n        return `https://${maStrSplit[2]}${tcpPort == null || tcpPort === '443' ? '' : `:${tcpPort}`}`;\n    }\n    throw new Error('invalid multiaddr: ' + ma.toString());\n}\nexport function cleanMultiaddr(maStr) {\n    const legacy = '/libp2p-webrtc-star';\n    if (maStr.startsWith(legacy)) {\n        maStr = maStr.substring(legacy.length, maStr.length);\n        let ma = multiaddr(maStr);\n        const tuppleIPFS = ma.stringTuples().filter((tupple) => {\n            return tupple[0] === 421; // ipfs code\n        })[0];\n        if (tuppleIPFS[1] == null) {\n            throw new Error('invalid multiaddr: ' + maStr);\n        }\n        ma = ma.decapsulate('p2p');\n        ma = ma.encapsulate('/p2p-webrtc-star');\n        ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);\n        maStr = ma.toString();\n    }\n    return maStr;\n}\n//# sourceMappingURL=utils.js.map","import { logger } from '@libp2p/logger';\nimport errCode from 'err-code';\nimport { connect } from 'socket.io-client';\nimport pDefer from 'p-defer';\nimport { WebRTCReceiver } from '@libp2p/webrtc-peer';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { cleanUrlSIO } from './utils.js';\nimport { CODE_P2P } from './constants.js';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nconst log = logger('libp2p:webrtc-star:listener');\nconst sioOptions = {\n    transports: ['websocket'],\n    path: '/socket.io-next/' // This should be removed when socket.io@2 support is removed\n};\nclass SigServer extends EventEmitter {\n    constructor(signallingUrl, signallingAddr, upgrader, handler, channelOptions) {\n        super();\n        this.signallingAddr = signallingAddr;\n        this.socket = connect(signallingUrl, sioOptions);\n        this.connections = [];\n        this.channels = new Map();\n        this.pendingSignals = new Map();\n        this.upgrader = upgrader;\n        this.handler = handler;\n        this.channelOptions = channelOptions;\n        this.handleWsHandshake = this.handleWsHandshake.bind(this);\n        let previouslyConnected = false;\n        this.socket.on('connect_error', err => {\n            // @ts-expect-error `.type` is missing from the types\n            if (previouslyConnected && err.type === 'TransportError') {\n                // if we've had an open connection before, and this is a\n                // transport error, let socket.io's reconnect logic take over\n                return;\n            }\n            this.dispatchEvent(new CustomEvent('error', {\n                detail: err\n            }));\n        });\n        this.socket.on('error', (err) => {\n            this.dispatchEvent(new CustomEvent('error', {\n                detail: err\n            }));\n        });\n        this.socket.on('ws-handshake', this.handleWsHandshake);\n        this.socket.on('ws-peer', (maStr) => {\n            this.dispatchEvent(new CustomEvent('peer', {\n                detail: maStr\n            }));\n        });\n        this.socket.on('connect', () => {\n            this.socket.emit('ss-join', this.signallingAddr.toString());\n            if (previouslyConnected) {\n                this.dispatchEvent(new CustomEvent('reconnect'));\n            }\n        });\n        this.socket.once('connect', () => {\n            // make sure we can reconnect in future\n            previouslyConnected = true;\n            this.dispatchEvent(new CustomEvent('listening'));\n        });\n        this.socket.on('disconnect', () => {\n            this.dispatchEvent(new CustomEvent('disconnect'));\n        });\n    }\n    _createChannel(intentId, srcMultiaddr, dstMultiaddr) {\n        const channelOptions = {\n            ...this.channelOptions\n        };\n        const channel = new WebRTCReceiver(channelOptions);\n        const onError = (evt) => {\n            const err = evt.detail;\n            log.error('incoming connection errored', err);\n        };\n        channel.addEventListener('error', onError);\n        channel.addEventListener('close', () => {\n            channel.removeEventListener('error', onError);\n        }, {\n            once: true\n        });\n        channel.addEventListener('signal', (evt) => {\n            const signal = evt.detail;\n            this.socket.emit('ss-handshake', {\n                intentId,\n                srcMultiaddr,\n                dstMultiaddr,\n                answer: true,\n                signal\n            });\n        });\n        channel.addEventListener('ready', () => {\n            const maConn = toMultiaddrConnection(channel, { remoteAddr: this.signallingAddr });\n            log('new inbound connection %s', maConn.remoteAddr);\n            try {\n                this.upgrader.upgradeInbound(maConn)\n                    .then(conn => {\n                    log('inbound connection %s upgraded', maConn.remoteAddr);\n                    this.connections.push(maConn);\n                    const untrackConn = () => {\n                        this.connections = this.connections.filter(c => c !== maConn);\n                        this.channels.delete(intentId);\n                        this.pendingSignals.delete(intentId);\n                    };\n                    channel.addEventListener('close', untrackConn, {\n                        once: true\n                    });\n                    this.dispatchEvent(new CustomEvent('connection', {\n                        detail: conn\n                    }));\n                    this.handler(conn);\n                })\n                    .catch(err => {\n                    log.error('inbound connection failed to upgrade', err);\n                    maConn.close().catch(err => {\n                        log.error('inbound connection failed to close after failing to upgrade', err);\n                    });\n                });\n            }\n            catch (err) {\n                log.error('inbound connection failed to upgrade', err);\n                maConn.close().catch(err => {\n                    log.error('inbound connection failed to close after failing to upgrade', err);\n                });\n            }\n        }, {\n            once: true\n        });\n        return channel;\n    }\n    handleWsHandshake(offer) {\n        log('incoming handshake. signal type \"%s\" is answer %s', offer.signal.type, offer.answer);\n        if (offer.answer === true || offer.err != null || offer.intentId == null) {\n            return;\n        }\n        const intentId = offer.intentId;\n        let pendingSignals = this.pendingSignals.get(intentId);\n        if (pendingSignals == null) {\n            pendingSignals = [];\n            this.pendingSignals.set(intentId, pendingSignals);\n        }\n        pendingSignals.push(offer);\n        let channel = this.channels.get(intentId);\n        if (channel == null) {\n            if (offer.signal.type !== 'offer') {\n                log('handshake is not an offer and channel does not exist, buffering until we receive an offer');\n                return;\n            }\n            log('creating new channel to handle offer handshake');\n            channel = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr);\n            this.channels.set(intentId, channel);\n        }\n        else {\n            log('channel already exists, using it to handle handshake');\n        }\n        while (pendingSignals.length > 0) {\n            const handshake = pendingSignals.shift();\n            if (handshake?.signal != null) {\n                channel.handleSignal(handshake.signal);\n            }\n        }\n    }\n    async close() {\n        // Close listener\n        this.socket.emit('ss-leave', this.signallingAddr.toString());\n        this.socket.removeAllListeners();\n        this.socket.close();\n        await Promise.all([\n            ...this.connections.map(async (maConn) => { await maConn.close(); }),\n            ...Array.from(this.channels.values()).map(async (channel) => { await channel.close(); })\n        ]);\n        this.dispatchEvent(new CustomEvent('close'));\n    }\n}\nclass WebRTCListener extends EventEmitter {\n    constructor(upgrader, handler, peerId, transport, options) {\n        super();\n        this.upgrader = upgrader;\n        this.handler = handler;\n        this.peerId = peerId;\n        this.transport = transport;\n        this.options = options;\n    }\n    async listen(ma) {\n        // Should only be used if not already listening\n        if (this.listeningAddr != null) {\n            throw errCode(new Error('listener already in use'), 'ERR_ALREADY_LISTENING');\n        }\n        const defer = pDefer(); // eslint-disable-line @typescript-eslint/no-invalid-void-type\n        // Should be kept unmodified\n        this.listeningAddr = ma;\n        let signallingAddr;\n        if (!ma.protoCodes().includes(CODE_P2P)) {\n            signallingAddr = ma.encapsulate(`/p2p/${this.peerId.toString()}`);\n        }\n        else {\n            signallingAddr = ma;\n        }\n        const signallingUrl = this.signallingUrl = cleanUrlSIO(ma);\n        log('connecting to signalling server on: %s', this.signallingUrl);\n        const server = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions);\n        server.addEventListener('error', (evt) => {\n            const err = evt.detail;\n            log('error connecting to signalling server %o', err);\n            server.close().catch(err => {\n                log.error('error closing server after error', err);\n            });\n            defer.reject(err);\n        });\n        server.addEventListener('listening', () => {\n            log('connected to signalling server');\n            this.dispatchEvent(new CustomEvent('listening'));\n            defer.resolve();\n        });\n        server.addEventListener('peer', (evt) => {\n            this.transport.peerDiscovered(evt.detail);\n        });\n        server.addEventListener('connection', (evt) => {\n            const conn = evt.detail;\n            if (conn.remoteAddr == null) {\n                try {\n                    conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toString()}`);\n                }\n                catch (err) {\n                    log.error('could not determine remote address', err);\n                }\n            }\n            this.dispatchEvent(new CustomEvent('connection', {\n                detail: conn\n            }));\n        });\n        server.addEventListener('disconnect', () => {\n            // Ensure we error if we try to dial while we are disconnected from\n            // the signalling server\n            this.transport.sigServers.delete(signallingUrl);\n        });\n        server.addEventListener('reconnect', () => {\n            // We can dial via the signalling server again\n            this.transport.sigServers.set(signallingUrl, server);\n        });\n        // Store listen and signal reference addresses\n        this.transport.sigServers.set(this.signallingUrl, server);\n        await defer.promise;\n    }\n    async close() {\n        if (this.signallingUrl != null) {\n            const server = this.transport.sigServers.get(this.signallingUrl);\n            if (server != null) {\n                await server.close();\n                this.transport.sigServers.delete(this.signallingUrl);\n            }\n        }\n        this.dispatchEvent(new CustomEvent('close'));\n        // Reset state\n        this.listeningAddr = undefined;\n    }\n    getAddrs() {\n        if (this.listeningAddr != null) {\n            return [\n                this.listeningAddr\n            ];\n        }\n        return [];\n    }\n}\nexport function createListener(upgrader, handler, peerId, transport, options) {\n    return new WebRTCListener(upgrader, handler, peerId, transport, options);\n}\n//# sourceMappingURL=listener.js.map","/**\n * To guarantee Uint8Array semantics, convert nodejs Buffers\n * into vanilla Uint8Arrays\n */\nexport function asUint8Array(buf) {\n    if (globalThis.Buffer != null) {\n        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    return buf;\n}\n//# sourceMappingURL=as-uint8array.js.map","import { asUint8Array } from './util/as-uint8array.js';\n/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc(size = 0) {\n    if (globalThis.Buffer?.alloc != null) {\n        return asUint8Array(globalThis.Buffer.alloc(size));\n    }\n    return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0) {\n    if (globalThis.Buffer?.allocUnsafe != null) {\n        return asUint8Array(globalThis.Buffer.allocUnsafe(size));\n    }\n    return new Uint8Array(size);\n}\n//# sourceMappingURL=alloc.js.map","// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n","const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n","import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n","import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n","import { from } from './base.js'\n\nconst alphabet = Array.from('ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚')\nconst alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])))\nconst alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])))\n\n/**\n * @param {Uint8Array} data\n * @returns {string}\n */\nfunction encode (data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction decode (str) {\n  const byts = []\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))]\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: 'ðŸš€',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n","import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n","import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n","import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n","// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n","// @ts-check\n\nimport { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n","// @ts-check\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => textEncoder.encode(JSON.stringify(node))\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => JSON.parse(textDecoder.decode(data))\n","// @ts-check\n\nimport * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nconst bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nconst hashes = { ...sha2, ...identity }\nconst codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes, hashes, bases, codecs }\n","import { bases } from 'multiformats/basics';\nimport { allocUnsafe } from '../alloc.js';\nfunction createCodec(name, prefix, encode, decode) {\n    return {\n        name,\n        prefix,\n        encoder: {\n            name,\n            prefix,\n            encode\n        },\n        decoder: {\n            decode\n        }\n    };\n}\nconst string = createCodec('utf8', 'u', (buf) => {\n    const decoder = new TextDecoder('utf8');\n    return 'u' + decoder.decode(buf);\n}, (str) => {\n    const encoder = new TextEncoder();\n    return encoder.encode(str.substring(1));\n});\nconst ascii = createCodec('ascii', 'a', (buf) => {\n    let string = 'a';\n    for (let i = 0; i < buf.length; i++) {\n        string += String.fromCharCode(buf[i]);\n    }\n    return string;\n}, (str) => {\n    str = str.substring(1);\n    const buf = allocUnsafe(str.length);\n    for (let i = 0; i < str.length; i++) {\n        buf[i] = str.charCodeAt(i);\n    }\n    return buf;\n});\nconst BASES = {\n    utf8: string,\n    'utf-8': string,\n    hex: bases.base16,\n    latin1: ascii,\n    ascii,\n    binary: ascii,\n    ...bases\n};\nexport default BASES;\n//# sourceMappingURL=bases.js.map","import bases, {} from './util/bases.js';\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString(array, encoding = 'utf8') {\n    const base = bases[encoding];\n    if (base == null) {\n        throw new Error(`Unsupported encoding \"${encoding}\"`);\n    }\n    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');\n    }\n    // strip multibase prefix\n    return base.encoder.encode(array).substring(1);\n}\n//# sourceMappingURL=to-string.js.map","import { logger } from '@libp2p/logger';\nimport errcode from 'err-code';\nimport { AbortError } from 'abortable-iterator';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport * as mafmt from '@multiformats/mafmt';\nimport { CODE_CIRCUIT } from './constants.js';\nimport { createListener } from './listener.js';\nimport { toMultiaddrConnection } from './socket-to-conn.js';\nimport { cleanMultiaddr, cleanUrlSIO } from './utils.js';\nimport { WebRTCInitiator } from '@libp2p/webrtc-peer';\nimport randomBytes from 'iso-random-stream/src/random.js';\nimport { toString as uint8ArrayToString } from 'uint8arrays';\nimport { EventEmitter, CustomEvent } from '@libp2p/interfaces/events';\nimport { peerIdFromString } from '@libp2p/peer-id';\nimport { symbol } from '@libp2p/interface-transport';\nimport { symbol as peerDiscoverySymbol } from '@libp2p/interface-peer-discovery';\nconst webrtcSupport = 'RTCPeerConnection' in globalThis;\nconst log = logger('libp2p:webrtc-star');\nconst noop = () => { };\nexport class WebRTCStarDiscovery extends EventEmitter {\n    constructor() {\n        super(...arguments);\n        this.started = false;\n    }\n    get [peerDiscoverySymbol]() {\n        return true;\n    }\n    get [Symbol.toStringTag]() {\n        return '@libp2p/webrtc-star-discovery';\n    }\n    isStarted() {\n        return this.started;\n    }\n    async start() {\n        this.started = true;\n    }\n    async stop() {\n        this.started = false;\n    }\n    dispatchEvent(event) {\n        if (!this.isStarted()) {\n            return false;\n        }\n        return super.dispatchEvent(event);\n    }\n}\n/**\n * @class WebRTCStar\n */\nexport class WebRTCStar {\n    constructor(init) {\n        if (init?.wrtc != null) {\n            this.wrtc = init.wrtc;\n        }\n        // Keep Signalling references\n        this.sigServers = new Map();\n        // Discovery\n        this._discovery = new WebRTCStarDiscovery();\n        this.discovery = () => this._discovery;\n        this.peerDiscovered = this.peerDiscovered.bind(this);\n    }\n    get [symbol]() {\n        return true;\n    }\n    get [Symbol.toStringTag]() {\n        return '@libp2p/webrtc-star';\n    }\n    async dial(ma, options) {\n        const rawConn = await this._connect(ma, options);\n        const maConn = toMultiaddrConnection(rawConn, { remoteAddr: ma, signal: options.signal });\n        log('new outbound connection %s', maConn.remoteAddr);\n        const conn = await options.upgrader.upgradeOutbound(maConn);\n        log('outbound connection %s upgraded', maConn.remoteAddr);\n        return conn;\n    }\n    async _connect(ma, options) {\n        if (options.signal?.aborted === true) {\n            throw new AbortError();\n        }\n        const channelOptions = {\n            ...(options.channelOptions ?? {})\n        };\n        // Use custom WebRTC implementation\n        if (this.wrtc != null) {\n            channelOptions.wrtc = this.wrtc;\n        }\n        const cOpts = ma.toOptions();\n        const intentId = uint8ArrayToString(randomBytes(36), 'hex');\n        return await new Promise((resolve, reject) => {\n            const sio = this.sigServers.get(cleanUrlSIO(ma));\n            if (sio?.socket == null) {\n                reject(errcode(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'));\n                return;\n            }\n            let connected = false;\n            log('dialing %s:%s', cOpts.host, cOpts.port);\n            const channel = new WebRTCInitiator(channelOptions);\n            const onError = (evt) => {\n                const err = evt.detail;\n                if (!connected) {\n                    const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`;\n                    log.error(msg);\n                    done(err);\n                }\n            };\n            const onReady = () => {\n                connected = true;\n                log('connection opened %s:%s', cOpts.host, cOpts.port);\n                done();\n            };\n            const onAbort = () => {\n                log.error('connection aborted %s:%s', cOpts.host, cOpts.port);\n                channel.close().finally(() => {\n                    done(new AbortError());\n                });\n            };\n            const done = (err) => {\n                channel.removeEventListener('ready', onReady);\n                options.signal?.removeEventListener('abort', onAbort);\n                if (err == null) {\n                    resolve(channel);\n                }\n                else {\n                    reject(err);\n                }\n            };\n            channel.addEventListener('ready', onReady, {\n                once: true\n            });\n            channel.addEventListener('close', () => {\n                channel.removeEventListener('error', onError);\n            });\n            options.signal?.addEventListener('abort', onAbort);\n            channel.addEventListener('signal', (evt) => {\n                const signal = evt.detail;\n                sio.socket.emit('ss-handshake', {\n                    intentId,\n                    srcMultiaddr: sio.signallingAddr.toString(),\n                    dstMultiaddr: ma.toString(),\n                    signal\n                });\n            });\n            sio.socket.on('ws-handshake', (offer) => {\n                if (offer.intentId === intentId && offer.err != null) {\n                    channel.close().finally(() => {\n                        reject(errcode(new Error(offer.err), 'ERR_SIGNALLING_FAILED'));\n                    });\n                }\n                if (offer.intentId !== intentId || offer.answer == null || channel.closed) {\n                    return;\n                }\n                channel.handleSignal(offer.signal);\n            });\n        });\n    }\n    /**\n     * Creates a WebrtcStar listener. The provided `handler` function will be called\n     * anytime a new incoming Connection has been successfully upgraded via\n     * `upgrader.upgradeInbound`.\n     */\n    createListener(options) {\n        if (!webrtcSupport && this.wrtc == null) {\n            throw errcode(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT');\n        }\n        options.channelOptions = options.channelOptions ?? {};\n        if (this.wrtc != null) {\n            options.channelOptions.wrtc = this.wrtc;\n        }\n        if (this.peerId == null) {\n            throw errcode(new Error('PeerId not set'), 'ERR_MISSING_PEER_ID');\n        }\n        return createListener(options.upgrader, options.handler ?? noop, this.peerId, this, options);\n    }\n    /**\n     * Takes a list of `Multiaddr`s and returns only valid TCP addresses\n     */\n    filter(multiaddrs) {\n        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n        return multiaddrs.filter((ma) => {\n            if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n                return false;\n            }\n            return mafmt.P2PWebRTCStar.matches(ma);\n        });\n    }\n    peerDiscovered(maStr) {\n        log('peer discovered: %s', maStr);\n        maStr = cleanMultiaddr(maStr);\n        const ma = multiaddr(maStr);\n        const peerIdStr = ma.getPeerId();\n        if (peerIdStr == null) {\n            return;\n        }\n        const peerId = peerIdFromString(peerIdStr);\n        this._discovery.dispatchEvent(new CustomEvent('peer', {\n            detail: {\n                id: peerId,\n                multiaddrs: [ma],\n                protocols: []\n            }\n        }));\n    }\n}\n//# sourceMappingURL=transport.js.map","import { WebRTCStar } from './transport.js';\nexport function webRTCStar(init = {}) {\n    const transport = new WebRTCStar(init);\n    return {\n        transport: (components) => {\n            transport.peerId = components.peerId;\n            return transport;\n        },\n        discovery: transport.discovery\n    };\n}\n//# sourceMappingURL=index.js.map"],"names":["CODE_P2P","CODE_CIRCUIT","CLOSE_TIMEOUT","log","logger","toMultiaddrConnection","socket","options","sink","source","maConn","abortableSource","err","start","timeout","host","port","cleanUrlSIO","ma","maStrSplit","tcpProto","wsProto","tcpPort","isName","cleanMultiaddr","maStr","legacy","multiaddr","tuppleIPFS","tupple","sioOptions","SigServer","EventEmitter","signallingUrl","signallingAddr","upgrader","handler","channelOptions","connect","previouslyConnected","CustomEvent","intentId","srcMultiaddr","dstMultiaddr","channel","WebRTCReceiver","onError","evt","signal","conn","untrackConn","c","offer","pendingSignals","handshake","WebRTCListener","peerId","transport","errCode","defer","pDefer","server","createListener","asUint8Array","buf","allocUnsafe","size","base","ALPHABET","name","BASE_MAP","j","i","x","xc","BASE","LEADER","FACTOR","iFACTOR","encode","zeroes","length","pbegin","pend","b58","carry","it1","it2","str","decodeUnsafe","psz","b256","it3","it4","vch","decode","string","buffer","src","_brrp__multiformats_scope_baseX","coerce","o","fromString","toString","b","Encoder","prefix","baseEncode","bytes","Decoder","baseDecode","text","decoder","or","ComposedDecoder","decoders","input","left","right","Codec","from","baseX","alphabet","basex","bitsPerChar","codes","end","out","bits","written","value","data","pad","mask","rfc4648","base10","base16","base16upper","base2","alphabetBytesToChars","p","alphabetCharsToBytes","byts","char","byt","base256emoji","base32","base32upper","base32pad","base32padupper","base32hex","base32hexupper","base32hexpad","base32hexpadupper","base32z","base36","base36upper","base58btc","base58flickr","base64","base64pad","base64url","base64urlpad","base8","identity","bases","identityBase","base58","createCodec","ascii","BASES","array","encoding","webrtcSupport","noop","WebRTCStarDiscovery","peerDiscoverySymbol","event","WebRTCStar","init","symbol","rawConn","AbortError","cOpts","uint8ArrayToString","randomBytes","resolve","reject","sio","errcode","connected","WebRTCInitiator","msg","done","onReady","onAbort","multiaddrs","mafmt.P2PWebRTCStar","peerIdStr","peerIdFromString","webRTCStar","components"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]}