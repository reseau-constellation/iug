{"version":3,"file":"valide-lmbSZfrd.js","sources":["../../../../node_modules/@constl/utils-ipa/dist/src/sfip.js","../../../../node_modules/@constl/utils-ipa/dist/src/valide.js"],"sourcesContent":["import { CID } from \"multiformats/cid\";\nimport { concat } from \"uint8arrays/concat\";\nexport function idcValide(idc) {\n    if (typeof idc === \"string\") {\n        try {\n            CID.parse(idc);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    return false;\n}\n// Identique à it-to-buffer, mais avec option de maximum de taille\nexport async function toBuffer(stream, max) {\n    let buffer = new Uint8Array(0);\n    for await (const buf of stream) {\n        buffer = concat([buffer, buf], buffer.length + buf.length);\n        if (max !== undefined && buffer.length > max)\n            return null;\n    }\n    return buffer;\n}\n//# sourceMappingURL=sfip.js.map","import { CID } from \"multiformats/cid\";\nimport { base58btc } from \"multiformats/bases/base58\";\nimport gjv from \"geojson-validation\";\nimport { idcValide } from \"./sfip.js\";\nimport { cholqij } from \"./cholqij.js\";\nexport const adresseOrbiteValide = (address) => {\n    // Code de @orbitdb/core\n    address = address.toString();\n    if (!address.startsWith(\"/orbitdb\") && !address.startsWith(\"\\\\orbitdb\")) {\n        return false;\n    }\n    address = address.replaceAll(\"/orbitdb/\", \"\");\n    address = address.replaceAll(\"\\\\orbitdb\\\\\", \"\");\n    address = address.replaceAll(\"/\", \"\");\n    address = address.replaceAll(\"\\\\\", \"\");\n    let idc;\n    try {\n        idc = CID.parse(address, base58btc);\n    }\n    catch {\n        return false;\n    }\n    return idc !== undefined;\n};\nexport const formatsFichiers = {\n    images: [\n        \"webp\",\n        \"svg\",\n        \"png\",\n        \"jpg\",\n        \"jpeg\",\n        \"jfif\",\n        \"pjpeg\",\n        \"pjp\",\n        \"gif\",\n        \"avif\",\n        \"apng\",\n    ],\n    vidéo: [\"mp4\"],\n    audio: [\"mp3\", \"ogg\", \"m4a\"],\n};\nexport const idcEtExt = (val) => {\n    try {\n        const [id, fichier] = val.split(\"/\");\n        if (idcValide(id)) {\n            const ext = fichier.split(\".\").pop();\n            if (ext) {\n                return {\n                    ext,\n                    fichier,\n                    id,\n                };\n            }\n        }\n    }\n    catch {\n        // Rien à faire\n    }\n    return undefined;\n};\nexport const devinerCatégorie = (val) => {\n    if (typeof val === \"boolean\")\n        return \"booléen\";\n    else if (typeof val === \"string\") {\n        try {\n            const [id, fichier] = val.split(\"/\");\n            if (idcValide(id)) {\n                const ext = fichier.split(\".\").pop();\n                if (ext && formatsFichiers.images.includes(ext))\n                    return \"image\";\n                else if (ext && formatsFichiers.vidéo.includes(ext))\n                    return \"vidéo\";\n                else if (ext && formatsFichiers.audio.includes(ext))\n                    return \"audio\";\n                else if (ext)\n                    return \"fichier\";\n            }\n        }\n        catch {\n            // Rien à faire\n        }\n        return adresseOrbiteValide(val) ? \"chaîne\" : \"chaîneNonTraductible\";\n    }\n    else if (typeof val === \"number\") {\n        if (val > 100000000000) {\n            return \"horoDatage\";\n        }\n        else {\n            return \"numérique\";\n        }\n    }\n    else if (Array.isArray(val)) {\n        if (val.length === 2 &&\n            val.every((x) => typeof x === \"number\" && x > 100000000000)) {\n            return \"intervaleTemps\";\n        }\n        else {\n            return undefined;\n        }\n    }\n    else if (gjv.valid(val)) {\n        return \"géojson\";\n    }\n    return undefined;\n};\nexport const estUnHoroDatage = (val) => {\n    if ([\"number\", \"string\"].includes(typeof val)) {\n        const date = new Date(val);\n        return !isNaN(date.valueOf());\n    }\n    else {\n        return cholqij.dateValide(val);\n    }\n};\nexport const validFichier = (val, exts) => {\n    if (typeof val !== \"string\")\n        return false;\n    let id;\n    let fichier;\n    try {\n        [id, fichier] = val.split(\"/\");\n    }\n    catch {\n        return false;\n    }\n    if (!fichier)\n        return false;\n    if (!idcValide(id))\n        return false;\n    if (exts) {\n        const ext = fichier.split(\".\").pop();\n        return !!ext && exts.includes(ext);\n    }\n    return true;\n};\nexport const validerCatégorieBase = ({ catégorie, val, }) => {\n    switch (catégorie) {\n        case \"numérique\":\n            return typeof val === \"number\";\n        case \"horoDatage\": {\n            return estUnHoroDatage(val);\n        }\n        case \"intervaleTemps\":\n            if (!Array.isArray(val))\n                return false;\n            if (val.length !== 2)\n                return false;\n            return val.every((d) => estUnHoroDatage(d));\n        case \"chaîne\":\n            return typeof val === \"string\" && adresseOrbiteValide(val);\n        case \"chaîneNonTraductible\":\n            return typeof val === \"string\";\n        case \"booléen\":\n            return typeof val === \"boolean\";\n        case \"géojson\":\n            if (!(typeof val === \"object\"))\n                return false;\n            return gjv.valid(val);\n        case \"vidéo\":\n            return validFichier(val, formatsFichiers.vidéo);\n        case \"audio\":\n            return validFichier(val, formatsFichiers.audio);\n        case \"image\":\n            return validFichier(val, formatsFichiers.images);\n        case \"fichier\":\n            return validFichier(val);\n        default:\n            return false;\n    }\n};\nexport function validerCatégorieVal({ val, catégorie, }) {\n    if (val === undefined)\n        return true; // Permettre les valeurs manquantes\n    if (catégorie.type === \"simple\") {\n        return validerCatégorieBase({ catégorie: catégorie.catégorie, val });\n    }\n    else {\n        if (Array.isArray(val)) {\n            return val.every((v) => validerCatégorieBase({ catégorie: catégorie.catégorie, val: v }));\n        }\n        else {\n            return false;\n        }\n    }\n}\n//# sourceMappingURL=valide.js.map"],"names":["idcValide","idc","CID","adresseOrbiteValide","address","base58btc","formatsFichiers","idcEtExt","val","id","fichier","ext","devinerCatégorie","x","gjv"],"mappings":"yDAEO,SAASA,EAAUC,EAAK,CAC3B,GAAI,OAAOA,GAAQ,SACf,GAAI,CACA,OAAAC,EAAI,MAAMD,CAAG,EACN,EACnB,MACc,CACF,MAAO,EACnB,CAEI,MAAO,EACX,CCRY,MAACE,EAAuBC,GAAY,CAG5C,GADAA,EAAUA,EAAQ,SAAU,EACxB,CAACA,EAAQ,WAAW,UAAU,GAAK,CAACA,EAAQ,WAAW,WAAW,EAClE,MAAO,GAEXA,EAAUA,EAAQ,WAAW,YAAa,EAAE,EAC5CA,EAAUA,EAAQ,WAAW,cAAe,EAAE,EAC9CA,EAAUA,EAAQ,WAAW,IAAK,EAAE,EACpCA,EAAUA,EAAQ,WAAW,KAAM,EAAE,EACrC,IAAIH,EACJ,GAAI,CACAA,EAAMC,EAAI,MAAME,EAASC,CAAS,CAC1C,MACU,CACF,MAAO,EACf,CACI,OAAOJ,IAAQ,MACnB,EACaK,EAAkB,CAC3B,OAAQ,CACJ,OACA,MACA,MACA,MACA,OACA,OACA,QACA,MACA,MACA,OACA,MACH,EACD,MAAO,CAAC,KAAK,EACb,MAAO,CAAC,MAAO,MAAO,KAAK,CAC/B,EACaC,EAAYC,GAAQ,CAC7B,GAAI,CACA,KAAM,CAACC,EAAIC,CAAO,EAAIF,EAAI,MAAM,GAAG,EACnC,GAAIR,EAAUS,CAAE,EAAG,CACf,MAAME,EAAMD,EAAQ,MAAM,GAAG,EAAE,IAAK,EACpC,GAAIC,EACA,MAAO,CACH,IAAAA,EACA,QAAAD,EACA,GAAAD,CACH,CAEjB,CACA,MACU,CAEV,CAEA,EACaG,EAAoBJ,GAAQ,CACrC,GAAI,OAAOA,GAAQ,UACf,MAAO,UACN,GAAI,OAAOA,GAAQ,SAAU,CAC9B,GAAI,CACA,KAAM,CAACC,EAAIC,CAAO,EAAIF,EAAI,MAAM,GAAG,EACnC,GAAIR,EAAUS,CAAE,EAAG,CACf,MAAME,EAAMD,EAAQ,MAAM,GAAG,EAAE,IAAK,EACpC,GAAIC,GAAOL,EAAgB,OAAO,SAASK,CAAG,EAC1C,MAAO,QACN,GAAIA,GAAOL,EAAgB,MAAM,SAASK,CAAG,EAC9C,MAAO,QACN,GAAIA,GAAOL,EAAgB,MAAM,SAASK,CAAG,EAC9C,MAAO,QACN,GAAIA,EACL,MAAO,SAC3B,CACA,MACc,CAEd,CACQ,OAAOR,EAAoBK,CAAG,EAAI,SAAW,sBACrD,KACS,IAAI,OAAOA,GAAQ,SACpB,OAAIA,EAAM,KACC,aAGA,YAGV,GAAI,MAAM,QAAQA,CAAG,EACtB,OAAIA,EAAI,SAAW,GACfA,EAAI,MAAOK,GAAM,OAAOA,GAAM,UAAYA,EAAI,IAAY,EACnD,iBAGP,OAGH,GAAIC,EAAI,MAAMN,CAAG,EAClB,MAAO,UAGf","x_google_ignoreList":[0,1]}